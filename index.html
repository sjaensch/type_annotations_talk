<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <title>reveal.js</title>

        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/beige.css">

        <!-- Theme used for syntax highlighting of code -->
        <link rel="stylesheet" href="lib/css/zenburn.css">

        <link rel="stylesheet" href="vendor/highlight.js/styles/ocean.css">

        
        <style>
            section {
                font-size: larger !important;
                padding: 0 !important;
            }
            pre code {
                max-height: 100% !important;
                font-size: larger !important;
            }
            code.text {
                background-color: #fed;
            }
            img {
                border: 0 !important;
            }
            .reveal .slides section .fragment.current-only {
                opacity: 1;
                visibility: visible;
                display: none;
            }
            .reveal .slides section .fragment.current-only.current-fragment {
                display: block;
            }
            .line {
                display: block;
            }
            .line.focus {
                background: #111;
                font-weight: bold;
            }
        </style>

        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>
    </head>
    <body>
        <div class="reveal">
            <div class="slides">
                

                <section data-background="images/title-slide-background.png">
                    <h2>Migrating existing codebases to using type annotations</h2>
                    <p><small>Stephan Jaensch<br />@s_jaensch</small></p>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Yelp's mission</h3>

                    <p>To connect people to great local businesses</p>

                    <img src="images/yelp_mission_icons.png" style="box-shadow: none;" />

                    <aside class="notes">
                        <ul>
                            <li>We have over 100 million reviews online to help you select just the right one</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>What I'll talk about</h3>

                    <ul>
                        <li>What are type annotations, and why you should use them</li>
                        <li class="fragment">How do you incrementally migrate an existing codebase to them</li>
                        <li class="fragment">What are some issues you might encounter</li>
                        <li class="fragment">How can type annotations help across services</li>
                    </ul>

                    <aside class="notes">
                        <ul>
                            <li>I promise the what and why will be short</li>
                            <li>I'm by no means an expert on type annotations, I'm just talking about what I learned as a user</li>
                            <li>If you have tips or improvements to share, please come talk to me afterwards or contact me by email / twitter</li>
                        </ul>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Type annotations - the what and why</h3>

                    <pre><code class="python" data-trim>
def hello(who: str) -> str:
    return 'Hello, {}'.format(who)

hello(5)
                    </code></pre>

                    <pre class="fragment"><code class="text" data-trim>
error: Argument 1 to "hello" has incompatible type "int";
 expected "str"
                    </code></pre>

                    <aside class="notes">
                        <ul>
                            <li>Yes it's an obvious mistake, plus the code would still work</li>
                            <li>But hopefully you're already convinced about type annotations</li>
                            <li>Much less clear when data gets passed around between modules, call stack gets deep</li>
                            <li>Also if it was fine to call the function with an int you should say so</li>
                            <li>Big difference in attitude to "duck typing"</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Migrate a codebase to using type annotations</h3>

                    <ul>
                        <li>Goal: All code is type annotated</li>
                        <li>Incrementally annotate code</li>
                        <li>Make sure checks are run for annotated code</li>
                    </ul>
                    
                    <aside class="notes">
                        <ul>
                            <li>We want to distribute the task of annotating the codebase</li>
                            <li>We want to progressively improve the amount of annotated code, while protecting against regressions</li>
                            <li>Also, we do want to have type checking for the code that we already annotated. As we'll see, that is possible, although there are limitations.</li>
                        </ul>
                    </aside>
                </section>



                <section data-background="images/slide-background.png">
                    <h3>The mypy type checker</h3>

                    <img src="images/mypy-release.png" />

                    <aside class="notes">
                        <ul>
                            <li>mypy is the static type checker for Python</li>
                            <li>beta quality: rapid progress, but still has a few bugs and things it doesn't check correctly</li>
                            <li>expect having to do source code modifcations as you upgrade to a newer version</li>
                            <li>I'll also be using Python 3.6 syntax for annotations</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Enforce annotations</h3>

                    <pre><code class="ini" data-trim>
[mypy]
check_untyped_defs = True
disallow_untyped_calls = False
disallow_untyped_defs = True
follow_imports = silent
ignore_missing_imports = True
python_version = 3.6
strict_optional = True
warn_redundant_casts = True
                    </code></pre>

                    <p class="fragment" data-code-focus="2-4"></p>
                    <p class="fragment" data-code-focus="5-6"></p>
                    <p class="fragment" data-code-focus="8"></p>
                    
                    <aside class="notes">
                        <ul>
                            <li>Also check code that's not fully type annotated</li>
                            <li>non-annotated code is an error</li>
                            <li>Don't complain about issues in code we're not explicitly checking</li>
                            <li>Make sure you treat None correctly everywhere, significant source of bugs</li>
                            <li>mypy has a --strict option that's even stricter than this configuration - need to strike a balance between cost and benefit, especially since e.g. decorators are not always easy to annotate</li>
                            <li>So now we know how mypy needs to be configured, but how do we check newly committed code?</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Checking source code on commit</h3>

                    <img src="images/pre-commit.png" />
                    
                    <aside class="notes">
                        <ul>
                            <li>Yelp has you covered, we open sourced pre-commit</li>
                            <li>"Hooks" check your code on commit</li>
                            <li>Many hooks for a lot of different languages available</li>
                            <li>Very good Python support, as we are heavy Python users</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Configuring pre-commit</h3>

                    <pre><code class="yaml" data-trim>
-   repo: local
    hooks:
    -   id: mypy
        name: mypy
        entry: mypy
        language: python
        language_version: 'python3.6'
        additional_dependencies: ['mypy']
        args: ['--config-file', 'mypy-pre-commit.ini']
        files: ^package_name/.+\.py$
                    </code></pre>

                    <p class="fragment" data-code-focus="9-10"></p>

                    <pre class="fragment"><code class="bash" data-trim>pre-commit install -f --install-hooks</code></pre>
                    
                    <aside class="notes">
                        <ul>
                            <li>Create a .pre-commit-config.yaml file in your project directory</li>
                            <li>Save the mypy configuration we just discussed, and tell mypy to use it</li>
                            <li>Make sure everybody has the hooks installed: Run the install command as part of your test suite, or during a "setup" step</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Checking source code on commit</h3>

                    <img src="images/pre-commit-mypy.png" />

                    <aside class="notes">
                        <ul>
                            <li>I modified media.py, our pre-commit hook informs me that I forgot to fully annotate two functions; I also passed an argument of the wrong type to GetPhotosFuture</li>
                            <li>As you can see, there's many more hooks you can run to improve code consistency and quality</li>
                            <li>Note that this is not a foolproof solution; developers can skip individual hooks or pre-commit altogether</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Running mypy as part of your test suite</h3>

                    <pre><code class="ini" data-trim>
[mypy]
ignore_missing_imports = True
python_version = 3.6
strict_optional = True
warn_redundant_casts = True
                    </code></pre>
                    
                    <aside class="notes">
                        <ul>
                            <li>Less strict, totally OK to have non-annotated code</li>
                            <li>Once you call a function that is not annotated all type information for the arguments passed in is lost</li>
                            <li>In the beginning you won't notice much of an improvement in terms of bug prevention - keep at it!</li>
                        </ul>
                    </aside>
                </section>



                <section data-background="images/slide-background.png">
                    <h3>Type your data</h3>

                    <pre><code class="python" data-trim>
from typing import Iterable, NamedTuple, Optional

class Business(NamedTuple):
    id: int
    name: str
    photos: Iterable[Photo]
    address1: Optional[str]
    address2: Optional[str]
    address3: Optional[str]
    city: str
    latitude: float
    longitude: float
    ...
                    </code></pre>

                    <p class="fragment" data-code-focus="6"></p>

                    <aside class="notes">
                        <ul>
                            <li>A lot of bugs happen because opaque dictionaries are passed around</li>
                            <li>Even worse, sometimes these dictionaries are mutated along the way</li>
                            <li>NamedTuples are a great way to defining your data contract, plus they're immutable</li>
                            <li>As you can see here, you can nest definitions</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>typed dictionaries</h3>

                    <pre><code class="python" data-trim>
from typing import Optional
from mypy_extensions import TypedDict

class BusinessDict(TypedDict):
    id: int
    name: str
    address1: Optional[str]
    address2: Optional[str]
                    </code></pre>

                    <pre class="fragment"><code class="python" data-trim>
business = BusinessDict(
    id=42, name='Yelp', address1=None, address2=None,
)
value = business.get('adress2', '')
                    </code></pre>

                    <pre class="fragment"><code class="text" data-trim>
error: TypedDict "BusinessDict" has no key 'adress2'
                    </code></pre>

                    <aside class="notes">
                        <ul>
                            <li>Unlike maps in other languages, you can have different types based on the key name</li>
                            <li>So even if you can't or don't want to do the work to convert your dicts to namedtuples, you can annotate those dicts and give them such a type</li>
                            <li>We can even use those classes in our code, just like we would with an untyped dict</li>
                            <li>And mypy will protect us from a class of pretty insidious bugs: no exception is raised, the code seems to function properly but returns the wrong data</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>How to type the helper function?</h3>

                    <pre><code class="python" data-trim>
def namedtuple_from_dict(
    nt_class,
    dict_values,
):
    """Create a namedtuple from a dict, using the namedtuple
    attribute names to look up values in the dict."""
    return nt_class._make(
        dict_values.get(k) for k in nt_class._fields
    )
                    </code></pre>

                    <aside class="notes">
                        <ul>
                            <li>One of our helper functions for working with namedtuples</li>
                            <li>Should be easy to annotate, right?</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>How to type the helper function?</h3>

                    <pre><code class="python" data-trim>
def namedtuple_from_dict(
    nt_class: Type[NamedTuple],
    dict_values: Dict,
) -> NamedTuple:
    """Create a namedtuple from a dict, using the namedtuple
    attribute names to look up values in the dict."""
    return nt_class._make(
        dict_values.get(k) for k in nt_class._fields
    )
                    </code></pre>

                    <p class="fragment" data-code-focus="2-4"></p>

                    <pre class="fragment"><code class="text" data-trim>
error: Incompatible return value type
 (got "NamedTuple", expected "Business")
error: Argument 1 to "namedtuple_from_dict" has incompatible
 type "Type[Business]"; expected "Type[NamedTuple]"
                    </code></pre>

                    <aside class="notes">
                        <ul>
                            <li>nt_class is a NamedTuple class, not an instance, that's why we need to use Type</li>
                            <li>And we return an instance of that NamedTuple class</li>
                            <li>Unfortunately this doesn't work, as we do care about what NamedTuple instance we're returning</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Using Generics</h3>

                    <pre><code class="python" data-trim>
Struct = TypeVar('Struct', bound=NamedTuple)

def namedtuple_from_dict(
    nt_class: Type[Struct],
    dict_values: Dict,
) -> Struct:
    """Create a namedtuple from a dict, using the namedtuple
    attribute names to look up values in the dict."""
    return nt_class._make(
        dict_values.get(k) for k in nt_class._fields
    )
                    </code></pre>

                    <p class="fragment" data-code-focus="1"></p>
                    <p class="fragment" data-code-focus="4,6"></p>

                    <pre class="fragment"><code class="text" data-trim>
error: Value of type variable "Struct" of "namedtuple_from_dict"
 cannot be "Business"
                    </code></pre>

                    <aside class="notes">
                        <ul>
                            <li>So we read up on how generics work and implement that solution</li>
                            <li>We introduce a new TypeVar, and declare that a Struct must inherit from NamedTuple</li>
                            <li>Unfortunately, this doesn't work either: NamedTuple is not a class, but a class constructor</li>
                            <li>This is also the reason for the second error on the last slide, why Business was not acceptable instead of NamedTuple</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>The solution</h3>

                    <pre><code class="python" data-trim>
Struct = TypeVar('Struct')

def namedtuple_from_dict(
    nt_class: Type[Struct],
    dict_values: Dict,
) -> Struct:
    """Create a namedtuple from a dict, using the namedtuple
    attribute names to look up values in the dict."""
    return nt_class._make(    # type: ignore
        dict_values.get(k) for k in nt_class._fields  # type: ignore
    )
                    </code></pre>

                    <p class="fragment" data-code-focus="1"></p>
                    <p class="fragment" data-code-focus="9-10"></p>
                    <p class="fragment"><a href="https://github.com/python/mypy/issues/3915">https://github.com/python/mypy/issues/3915</a></p>

                    <aside class="notes">
                        <ul>
                            <li>We need to remove the bounding; but now all we know is that we receive a class of some type and return an instance</li>
                            <li>We lost knowledge about the fact that each of these classes will have a _field attribute and a _make method</li>
                            <li>So we need to tell mypy to ignore these errors</li>
                            <li>We still maintain the most important type information: the type of the instance we return</li>
                            <li>But mypy cannot tell us when we pass an argument in that is not a NamedTuple</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>NamedTuple and count / index</h3>

                    <pre><code class="python" data-trim>
class Pagination(NamedTuple):
    count: int
    index: int
                    </code></pre>

                    <pre class="fragment"><code class="text" data-trim>
error: Incompatible types in assignment (expression has type "int",
 base class "tuple" defined the type as
 "Callable[[Tuple[int, ...], Any], int]")

error: Incompatible types in assignment (expression has type "int",
 base class "tuple" defined the type as
 "Callable[[Tuple[int, ...], Any, int, int], int]")
                    </code></pre>

                    <aside class="notes">
                        <ul>
                            <li>tuples have index and count methods, our properties are shadowing them</li>
                            <li>The NamedTuple behaves as expected (we just can't call count or index anymore)</li>
                            <li>But mypy will complain as it doesn't allow us to redefine the type of those two properties</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Redefining the type of properties</h3>

                    <pre><code class="python" data-trim>
class RegistryMetaclass(type):
    """Error mapping registry class."""
    registry: Dict[str, Type['BaseErrorMapping']] = {}
    key_name: str = 'error_id'

class ValidationRegistryMetaclass(RegistryMetaclass):
    registry: Dict[str, Type['BaseValidationError']] = {}
    key_name = 'exc_cls'
                    </code></pre>

                    <pre class="fragment"><code class="text" data-trim>
error: Incompatible types in assignment (expression has type
 "Dict[str, Type[BaseValidationError]]", base class "RegistryMetaclass"
 defined the type as "Dict[str, Type[BaseErrorMapping]]")
                    </code></pre>

                    <p class="fragment"><a href="https://www.python.org/dev/peps/pep-0544/">https://www.python.org/dev/peps/pep-0544/</a></p>

                    <aside class="notes">
                        <ul>
                            <li>you can try defining the type in the base class as a union, but that can have other unintended consequences</li>
                            <li>The Protocols PEP will solve this and allow us to define behavior, i.e. support static duck typing</li>
                            <li>structural subtyping should also enable us to properly type the namedtuple_from_dict function</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>How to annotate descriptors</h3>

                    <pre><code class="python" data-trim>
T = TypeVar('T')
V = TypeVar('V')

class SetOnceProperty(Generic[T, V]):

    def __get__(self, instance: Optional[T], owner: Type[T])
     -> Union[V, 'SetOnceProperty']:
        if instance is None:
            return self
        return self._property_map[instance]

    def __set__(self, instance: T, value: V) -> None:
        if instance in self._property_map:
            raise AttributeError('this attribute can only be set once.')
        self._property_map[instance] = value


class BizAppContext():
    biz_user_id = SetOnceProperty['BizAppContext', int]()
    ...
                    </code></pre>

                    <p class="fragment" data-code-focus="4"></p>
                    <p class="fragment" data-code-focus="6-7"></p>
                    <p class="fragment" data-code-focus="13-14"></p>
                    <p class="fragment" data-code-focus="19"></p>

                    <img class="fragment" data-src="images/document-descriptors.png" />

                    <aside class="notes">
                        <ul>
                            <li>you can try defining the type in the base class as a union, but that can have other unintended consequences</li>
                            <li>The Protocols PEP will solve this and allow us to define behavior, i.e. support static duck typing</li>
                            <li>structural subtyping should also enable us to properly type the namedtuple_from_dict function</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Recursive types</h3>

                    <pre><code class="python" data-trim>
class Category(NamedTuple):
    id: int
    name: str
    children: List['Category']
                    </code></pre>

                    <pre class="fragment"><code class="text" data-trim>
error: Recursive types not fully supported yet,
 nested types replaced with "Any"
                    </code></pre>

                    <img class="fragment" data-src="images/recursive-types.png" />

                    <aside class="notes">
                        <ul>
                            <li>Another mypy limitation that you'll probably hit when working with a larger codebase</li>
                            <li>Tree-like data structures will probably be mostly untyped</li>
                            <li>You can add typing information with the cast function, but you'll have to remember to do this everywhere</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>The business fixture</h3>

                    <pre><code class="python" data-trim>
@pytest.fixture
def business_id(db_session):
    return business_factory.create(db_session)
                    </code></pre>

                    <pre class="fragment"><code class="python" data-trim>
def create(
    session,
    name='Levchins',
    …
):
    business = Business(
        name=name,
        …
    )
    session.add(business)
    session.commit()
    return business.id
                    </code></pre>

                    <aside class="notes">
                        <ul>
                            <li>Business fixture extremely short, real work done in our library</li>
                            <li>The create method is just a wrapper around an SQLAlchemy model</li>
                            <li>Provides reasonable defaults and DRY</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Why not use models directly?</h3>

                    <img src="images/biz_user_relationship.png" style="box-shadow: none;" />

                    <aside class="notes">
                        <ul>
                            <li>Some relational data needs to be created at the same time</li>
                            <li>We disable constraint checking in MySQL for scalability</li>
                            <li>All users have an email</li>
                            <li>If a business user has a business then let's create that relationship on user creation</li>
                            <li>This should mirror what your non-test code does when creating the database entries</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Why not use models directly?</h3>

                    <pre><code class="python" data-trim>
def biz_user_create(session, business_id=None, email=None, …):
    """Creates a biz_user with password 'password'"""
    biz_user = BizUser(
        …
    )
    session.add(biz_user)
    session.flush()

    session.add(
        BizUserPrivate(
            biz_user_id=biz_user.id,
            email=email,
        )
    )

    if business_id:
        add_biz_user_to_business(session, biz_user.id, business_id)

    session.commit()

    return biz_user.id
                    </code></pre>

                    <p class="fragment" data-code-focus="9-14"></p>
                    <p class="fragment" data-code-focus="17"></p>

                    <aside class="notes">
                        <ul>
                            <li>We insert data in at least two tables</li>
                            <li>Optionally inserting into a third table as well, using a function that can also be called independently</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Downstream services with data creation APIs</h3>

                    <pre><code class="python" data-trim>
@pytest.fixture
def question(question_answer_client, business_id, confirmed_user_id):
    return question_answer_client.business.create_question(
        body={
            'text': 'Test question...?',
            'platform_source': 'other',
            'subscription': False,
        },
        business_id=business_id,
    ).result().question
                    </code></pre>

                    <aside class="notes">
                        <ul>
                            <li>question_answer_client is a Swagger client, a tool for communicating between services</li>
                            <li>This fixture expects the data creation API to work</li>
                            <li>You could get a failure during fixture execution, which is harder to debug</li>
                            <li>Sometimes you're using that same API during other tests</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Pros and Cons</h3>

                    <ul>
                        <li>Natural fit for pytest fixtures</li>
                        <li class="fragment">Much easier data creation</li>
                        <li class="fragment">People create separate data entries for each test "automatically"</li>
                        <li class="fragment">Need to maintain data creation factories</li>
                        <li class="fragment">Potentially slower (not sharing data across tests)</li>
                    </ul>

                    <aside class="notes">
                        <ul>
                            <li>You can slowly migrate to data creation factories</li>
                            <li>No need to rewrite existing tests</li>
                            <li>Code in different codebases always adds some maintenance overhead</li>
                            <li>Use models from your data creation package in your service codebase if possible</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>How to make tests faster</h3>

                    <img src="images/parallel_test_execution.jpg" style="width: 80%" />

                    <p style="font-size: xx-small;">Source: http://www.methodsandtools.com/tools/selendroid.html</p>

                    <aside class="notes">
                        <ul>
                            <li>Two issues with end-to-end tests that write data</li>
                            <li>Tests not repeatable</li>
                            <li>Tests dependant on execution order</li>
                            <li>Both issues solved by using fixtures with data factories</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Execute tests in parallel with pytest</h3>

                    <pre><code class="python" data-trim>
$ pip install pytest-xdist
$ python -m pytest -s -vvv -n 4 tests/acceptance
                    </code></pre>

                    <img class="fragment" src="images/fix_tests_prelaunch.png" />

                    <aside class="notes">
                        <ul>
                            <li>Generally tests doing writes and sharing fixtures with tests that do reads are problematic</li>
                            <li>The issue comes with tests that share these fixtures - one expects a certain state, the other changes the state</li>
                            <li>The tests rely on a deterministic execution order - randomizing test execution order would make them just as flaky</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Execute tests in parallel with pytest</h3>

                    <img src="images/fix_tests_postlaunch.png" />

                    <aside class="notes">
                        <ul>
                            <li>We didn't observe significant speedups beyond four processes</li>
                            <li>reduced test execution time by ~60% compared to old setup</li>
                            <li>Creating the test environment (spinning up services) still takes a significant amount of time</li>
                            <li>Faster iteration when developing since you don't need to tear down and recreate it</li>
                        </ul>
                    </aside>
                </section>

                
                <section data-background="images/slide-background.png">
                    <h3>Takeaways</h3>

                    <ul>
                        <li>Use fixture factories for <strong>faster development</strong> and more correct test data</li>
                        <li class="fragment">Convert tests for <strong>test isolation and repeatability</strong></li>
                        <li class="fragment">Take advantage of it by executing tests in <strong>parallel</strong></li>
                    </ul>

                    <aside class="notes">
                        <ul>
                            <li>In summary, what we're aiming for is increasing both developer productivity as well as
                                developer happiness.</li>
                            <li>Easier to write tests, easier to iterate since you don't have to reset datastore state</li>
                            <li>If tests are not as hard to write developers are more likely to write them</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Other talks by Yelpers</h3>

                    <p>"Write more decorators (and fewer classes)"<br />by Antonio Verardi; Tuesday, 10:30, Anfiteatro 2</p>
                    <p>"Teeing up Python: Code Golf"<br />by Lee Sheng; Wednesday, 12:10, PyCharm Room</p>

                    <aside class="notes">
                    </aside>
                </section>


                <section data-background="images/check_out_yelp.png">
                    <br />
                    <aside class="notes">
                        <p>European offices!</p>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h2>Questions?</h2>

                    <p>&nbsp;</p>
                    <p>sjaensch@yelp.com / @s_jaensch</p>
                    <p>https://github.com/sjaensch/faster_end_to_end_tests_talk.git</p>
                </section>

            </div>
        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>

        <script>
            // More info https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                history: true,
                center: true,
                controls: false,
                width: '90%',
                height: '100%',
                margin: 0.0,

                // More info https://github.com/hakimel/reveal.js#dependencies
                // { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
                dependencies: [
                    { src: 'plugin/markdown/marked.js' },
                    { src: 'plugin/markdown/markdown.js' },
                    { src: 'plugin/notes/notes.js', async: true },
                    { src: 'vendor/highlight.js/highlight.pack.js' },
                    { src: 'node_modules/reveal-code-focus/reveal-code-focus.js', callback: function() { RevealCodeFocus(); } }
                ]
            });
        </script>
    </body>
</html>
