<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <title>reveal.js</title>

        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/beige.css">

        <!-- Theme used for syntax highlighting of code -->
        <link rel="stylesheet" href="lib/css/zenburn.css">

        <link rel="stylesheet" href="vendor/highlight.js/styles/ocean.css">

        
        <style>
            section {
                font-size: larger !important;
                padding: 0 !important;
            }
            pre code {
                max-height: 100% !important;
                font-size: larger !important;
            }
            code.text {
                background-color: #fed;
            }
            img {
                border: 0 !important;
            }
            .reveal .slides section .fragment.current-only {
                opacity: 1;
                visibility: visible;
                display: none;
            }
            .reveal .slides section .fragment.current-only.current-fragment {
                display: block;
            }
            .line {
                display: block;
            }
            .line.focus {
                background: #111;
                font-weight: bold;
            }
        </style>

        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>
    </head>
    <body>
        <div class="reveal">
            <div class="slides">
                

                <section data-background="images/title-slide-background.png">
                    <h2>Migrating existing codebases to using type annotations</h2>
                    <p><small>Stephan Jaensch<br />@s_jaensch</small></p>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Yelp's mission</h3>

                    <p>To connect people with great local businesses</p>

                    <img src="images/yelp_mission_icons.png" style="box-shadow: none;" />

                    <aside class="notes">
                        <ul>
                            <li>We have over 130 million reviews online to help you select just the right one</li>
                            <li>And we have about 30 million monthly mobile app unique users</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>What I'll talk about</h3>

                    <ul>
                        <li>What are type annotations, and why you should use them</li>
                        <li class="fragment">How do you incrementally migrate an existing codebase to them</li>
                        <li class="fragment">What are some issues you might encounter</li>
                        <li class="fragment">How can type annotations help across services</li>
                    </ul>

                    <aside class="notes">
                        <ul>
                            <li>I promise the what and why will be short</li>
                            <li>I'm by no means an expert on type annotations, I'm just talking about what I learned as a user</li>
                            <li>I'll be showing a lot of code to illustrate my examples</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Other talks about type annotations</h3>

                    <ul>
                        <li>Carl Meyer: Type-checked Python in the real world (Instagram)</li>
                        <li>Greg Price: Clearer Code at Scale: Static Types at Zulip and Dropbox</li>
                    </ul>

                    <aside class="notes">
                        <ul>
                            <li>If you'd like more introductory talks about type annotations, there weere two really good ones at PyCon US 2018.</li>
                            <li>Both of these talks do a great job explaining why you'd want to add type annotations</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Python type annotations</h3>

                    <pre><code class="python" data-trim>
def hello(who: str) -> str:
    return 'Hello, {}'.format(who)

hello(5)
                    </code></pre>

                    <pre class="fragment"><code class="text" data-trim>
error: Argument 1 to "hello" has incompatible type "int";
 expected "str"
                    </code></pre>

                    <pre class="fragment"><code class="python" data-trim>
def process_data(self, items):
    self.values = [item.value.id for item in items]
                    </code></pre>

                    <aside class="notes">
                        <ul>
                            <li>Yes it's an obvious mistake, plus the code would still work</li>
                            <li>Type annotations are documentation, so this indicates an error in your documentation</li>
                            <li>Much less clear when data gets passed around between modules, call stack gets deep</li>
                            <li>it's called values, but it's really value_ids, a type annotation might help when naming is imperfect</li>
                            <li>This is really a continuation of explicit is better than implicit</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Migrate a codebase to using type annotations</h3>

                    <ul>
                        <li>Goal: All code is type annotated</li>
                        <li>Incrementally annotate code</li>
                        <li>Make sure checks are run for annotated code</li>
                    </ul>
                    
                    <aside class="notes">
                        <ul>
                            <li>We want to distribute the task of annotating the codebase</li>
                            <li>We want to progressively improve the amount of annotated code, while protecting against regressions</li>
                            <li>We're going to do that on a per-file basis: As people touch a file, we expect them to annotate it</li>
                            <li>Also, we do want to have type checking for the code that we already annotated. As we'll see, that is possible, although there are limitations.</li>
                        </ul>
                    </aside>
                </section>



                <section data-background="images/slide-background.png">
                    <h3>The mypy type checker</h3>

                    <img src="images/mypy-release.png" />

                    <aside class="notes">
                        <ul>
                            <li>mypy is the static type checker for Python</li>
                            <li>beta quality: rapid progress, but still has a few bugs and things it doesn't check correctly</li>
                            <li>I'll also be using Python 3.6 syntax for annotations</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Pyre</h3>

                    <img src="images/pyre.png" />

                    <aside class="notes">
                        <ul>
                            <li>It's much faster for larger codebases</li>
                            <li>Is able to parallelize much of the work</li>
                            <li>We don't use it yet at Yelp</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Enforce annotations</h3>

                    <pre><code class="ini" data-trim>
[mypy]
check_untyped_defs = True
disallow_untyped_calls = False
disallow_untyped_defs = True
follow_imports = silent
ignore_missing_imports = True
python_version = 3.6
strict_optional = True
warn_redundant_casts = True
                    </code></pre>

                    <p class="fragment" data-code-focus="2-4"></p>
                    <p class="fragment" data-code-focus="5-6"></p>
                    <p class="fragment" data-code-focus="8"></p>
                    
                    <aside class="notes">
                        <ul>
                            <li>non-annotated code is an error</li>
                            <li>Don't complain about issues in code we're not explicitly checking</li>
                            <li>Make sure you treat None correctly everywhere, significant source of bugs</li>
                            <li>mypy has a --strict option that's even stricter than this configuration - need to strike a balance between cost and benefit, especially since e.g. decorators are not always easy to annotate</li>
                            <li>So now we know how mypy needs to be configured, but how do we check newly committed code?</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Checking source code on commit</h3>

                    <img src="images/pre-commit.png" />
                    
                    <aside class="notes">
                        <ul>
                            <li>Yelp has you covered, we open sourced pre-commit</li>
                            <li>"Hooks" check your code on commit</li>
                            <li>Many hooks for a lot of different languages available</li>
                            <li>Very good Python support, as we are heavy Python users</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Configuring pre-commit</h3>

                    <pre><code class="yaml" data-trim>
-   repo: local
    hooks:
    -   id: mypy
        name: mypy
        entry: mypy
        language: python
        language_version: 'python3.6'
        additional_dependencies: ['mypy']
        args: ['--config-file', 'mypy-pre-commit.ini']
        files: ^package_name/.+\.py$
                    </code></pre>

                    <p class="fragment" data-code-focus="9-10"></p>

                    <pre class="fragment"><code class="bash" data-trim>pre-commit install -f --install-hooks</code></pre>
                    
                    <aside class="notes">
                        <ul>
                            <li>Create a .pre-commit-config.yaml file in your project directory</li>
                            <li>Save the mypy configuration we just discussed, and tell mypy to use it</li>
                            <li>Make sure everybody has the hooks installed: Run the install command as part of your test suite, or during a "setup" step</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Checking source code on commit</h3>

                    <img src="images/pre-commit-mypy.png" />

                    <aside class="notes">
                        <ul>
                            <li>I modified media.py, our pre-commit hook informs me that I forgot to fully annotate two functions; I also passed an argument of the wrong type to GetPhotosFuture</li>
                            <li>As you can see, there's many more hooks you can run to improve code consistency and quality</li>
                            <li>Note that this is not a foolproof solution; developers can skip individual hooks or pre-commit altogether</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Running mypy as part of your test suite</h3>

                    <pre><code class="ini" data-trim>
[mypy]
ignore_missing_imports = True
python_version = 3.6
strict_optional = True
warn_redundant_casts = True
                    </code></pre>
                    
                    <aside class="notes">
                        <ul>
                            <li>Less strict, totally OK to have non-annotated code</li>
                            <li>Once you call a function that is not annotated we have no type checking at all for its return value!</li>
                            <li>In the beginning you won't notice much of an improvement in terms of bug prevention - keep at it!</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Auto-generating type annotations</h3>

                    <img src="images/monkeytype.png" />

                    <img class="fragment" src="images/pyannotate.png" />

                    <aside class="notes">
                        <ul>
                            <li>Great way to get started, but a developer needs to check all of the annotations</li>
                            <li>They might be too strict, or just plain wrong when you run them as part of your tests</li>
                            <li>PyAnnotate doesn't do Python 3 annotations, which is a real bummer. We've had good success with MonkeyType.</li>
                        </ul>
                    </aside>
                </section>

                <section data-background="images/slide-background.png">
                    <h3>Type your data</h3>

                    <pre><code class="python" data-trim>
from typing import Iterable, NamedTuple, Optional

class Business(NamedTuple):
    id: int
    name: str
    photos: Iterable[Photo]
    address1: Optional[str]
    address2: Optional[str]
    address3: Optional[str]
    city: str
    latitude: float
    longitude: float
    ...
                    </code></pre>

                    <p class="fragment" data-code-focus="6"></p>

                    <aside class="notes">
                        <ul>
                            <li>A lot of bugs happen because opaque dictionaries are passed around</li>
                            <li>Even worse, sometimes these dictionaries are mutated along the way</li>
                            <li>NamedTuples are a great way to defining your data contract, plus they're immutable</li>
                            <li>As you can see here, you can nest definitions</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>typed dictionaries</h3>

                    <pre><code class="python" data-trim>
from typing import Optional
from mypy_extensions import TypedDict

class BusinessDict(TypedDict):
    id: int
    name: str
    address1: Optional[str]
    address2: Optional[str]
                    </code></pre>

                    <pre class="fragment"><code class="python" data-trim>
def get_biz_address(business: BusinessDict) -> str:
    ...
    value = business.get('adress2', '')
                    </code></pre>

                    <pre class="fragment"><code class="text" data-trim>
error: TypedDict "BusinessDict" has no key 'adress2'
                    </code></pre>

                    <aside class="notes">
                        <ul>
                            <li>Unlike maps in other languages, you can have different types based on the key name</li>
                            <li>So even if you can't or don't want to do the work to convert your dicts to namedtuples, you can annotate those dicts and give them such a type</li>
                            <li>We can, but don't have to use those classes in our code, it's enough to use them as annotations</li>
                            <li>And mypy will protect us from a class of pretty insidious bugs: no exception is raised, the code seems to function properly but returns the wrong data</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>How to type the helper function?</h3>

                    <pre><code class="python" data-trim>
def namedtuple_from_dict(
    nt_class,
    dict_values,
):
    """Create a namedtuple from a dict, using the namedtuple
    attribute names to look up values in the dict."""
    return nt_class._make(
        dict_values.get(k) for k in nt_class._fields
    )
                    </code></pre>

                    <aside class="notes">
                        <ul>
                            <li>Hopefully you're convinced that you want to use type safe data structures, so let's use namedtuples everywhere!</li>
                            <li>To make that as easy as possible for developers, we provide a helper function for converting all of those untyped dictionaries into NamedTuples</li>
                            <li>It instantiates the NamedTuple class by looking up the property names of the NamedTuple in the dictionary - we use the NamedTuple definition as the source of truth for the data we want to keep</li>
                            <li>Should be easy to annotate, right?</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>How to type the helper function?</h3>

                    <pre><code class="python" data-trim>
def namedtuple_from_dict(
    nt_class: Type[NamedTuple],
    dict_values: Dict[str, Any],
) -> NamedTuple:
    """Create a namedtuple from a dict, using the namedtuple
    attribute names to look up values in the dict."""
    return nt_class._make(
        dict_values.get(k) for k in nt_class._fields
    )
                    </code></pre>

                    <p class="fragment" data-code-focus="2-4"></p>

                    <pre class="fragment"><code class="text" data-trim>
error: Incompatible return value type
 (got "NamedTuple", expected "Business")
error: Argument 1 to "namedtuple_from_dict" has incompatible
 type "Type[Business]"; expected "Type[NamedTuple]"
                    </code></pre>

                    <aside class="notes">
                        <ul>
                            <li>nt_class is a NamedTuple class, not an instance, that's why we need to use Type</li>
                            <li>This way to annotate dicts doesn't really tell us much about its contents</li>
                            <li>And we return an instance of that NamedTuple class</li>
                            <li>Unfortunately this doesn't work, as we do care about what NamedTuple instance we're returning</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Using Generics</h3>

                    <pre><code class="python" data-trim>
Struct = TypeVar('Struct', bound=NamedTuple)

def namedtuple_from_dict(
    nt_class: Type[Struct],
    dict_values: Dict,
) -> Struct:
    """Create a namedtuple from a dict, using the namedtuple
    attribute names to look up values in the dict."""
    return nt_class._make(
        dict_values.get(k) for k in nt_class._fields
    )
                    </code></pre>

                    <p class="fragment" data-code-focus="1"></p>
                    <p class="fragment" data-code-focus="4,6"></p>

                    <pre class="fragment"><code class="text" data-trim>
error: Value of type variable "Struct" of "namedtuple_from_dict"
 cannot be "Business"
                    </code></pre>

                    <aside class="notes">
                        <ul>
                            <li>So we read up on how generics work and implement that solution</li>
                            <li>We introduce a new TypeVar, and declare that a Struct must inherit from NamedTuple</li>
                            <li>Unfortunately, this doesn't work either: NamedTuple is not a class, but a class constructor</li>
                            <li>This is also the reason for the second error on the last slide, why Business was not acceptable instead of NamedTuple</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>The solution: Protocols</h3>

                    <pre><code class="python" data-trim>
from typing_extensions import Protocol

T = TypeVar('T')
class NTProto(Protocol):
    _source: str
    _fields: Tuple[str, ...]

    @classmethod
    def _make(cls: Type[T], iterable: Iterable[Any]) -> T: ...
    # add other methods, if needed

NT = TypeVar('NT', bound=NTProto)
def namedtuple_from_dict(
    nt_class: Type[NT],
    dict_values: Dict[str, Any],
) -> NT:
    return nt_class._make(
        dict_values.get(k) for k in nt_class._fields
    )
                    </code></pre>

                    <p class="fragment" data-code-focus="4"></p>
                    <p class="fragment" data-code-focus="6"></p>
                    <p class="fragment" data-code-focus="9"></p>
                    <p class="fragment" data-code-focus="12"></p>

                    <aside class="notes">
                        <ul>
                            <li>There's no base NamedTuple class, the only common base class is the Tuple</li>
                            <li>So we need a way to describe a certain behavior; this is what protocols do</li>
                            <li>with Protocols you describe duck typing</li>
                            <li>these are similar to Interfaces in Go or Protocols in Swift</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>NamedTuple and count / index</h3>

                    <pre><code class="python" data-trim>
class Pagination(NamedTuple):
    count: int
    index: int
                    </code></pre>

                    <pre class="fragment"><code class="text" data-trim>
error: Incompatible types in assignment (expression has type "int",
 base class "tuple" defined the type as
 "Callable[[Tuple[int, ...], Any], int]")

error: Incompatible types in assignment (expression has type "int",
 base class "tuple" defined the type as
 "Callable[[Tuple[int, ...], Any, int, int], int]")
                    </code></pre>

                    <aside class="notes">
                        <ul>
                            <li>tuples have index and count methods, our properties are shadowing them</li>
                            <li>The NamedTuple behaves as expected (we just can't call count or index anymore)</li>
                            <li>But mypy will complain as it doesn't allow us to redefine the type of those two properties</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>How to annotate descriptors</h3>

                    <pre><code class="python" data-trim>
T = TypeVar('T')
V = TypeVar('V')

class SetOnceProperty(Generic[T, V]):

    def __get__(self, instance: T, owner: Type[T]) -> V:
        return self._property_map[instance]

    def __set__(self, instance: T, value: V) -> None:
        if instance in self._property_map:
            raise AttributeError(
                'this attribute can only be set once.'
            )
        self._property_map[instance] = value

class BizAppContext():
    biz_user_id = SetOnceProperty['BizAppContext', int]()
    ...
                    </code></pre>

                    <p class="fragment" data-code-focus="4"></p>
                    <p class="fragment" data-code-focus="6"></p>
                    <p class="fragment" data-code-focus="9"></p>
                    <p class="fragment" data-code-focus="17"></p>

                    <img class="fragment" data-src="images/document-descriptors.png" />

                    <aside class="notes">
                        <ul>
                            <li>Generic class, T is the type of the object using the descriptor, V the type of the value the property will store</li>
                            <li>The __get__ method uses Type[T] for owner since it's the type of the instance</li>
                            <li>The __set__ method is where we implement the functionality</li>
                            <li>when we define biz_user_id we specify the two types, so now mypy knows biz_user_id is an int and will do proper type checking</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Recursive types</h3>

                    <pre><code class="python" data-trim>
class Category(NamedTuple):
    id: int
    name: str
    children: List['Category']
                    </code></pre>

                    <pre class="fragment"><code class="text" data-trim>
error: Recursive types not fully supported yet,
 nested types replaced with "Any"
                    </code></pre>

                    <img class="fragment" data-src="images/recursive-types.png" />

                    <aside class="notes">
                        <ul>
                            <li>Another mypy limitation that you'll probably hit when working with a larger codebase</li>
                            <li>Tree-like data structures will probably be mostly untyped</li>
                            <li>You can add typing information with the cast function, but you'll have to remember to do this everywhere</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h2>Type annotations with distributed code</h2>

                    <aside class="notes">
                        <ul>
                            <li>If you have a large legacy codebase, chances are you've started to invest in a service oriented architecture (we at Yelp certainly have)</li>
                            <li>I've spoken in the past about how we do distributed services at Yelp, and the challenges it poses in regards to reliability and testability with these codebases that get developed and deployed independently.</li>
                            <li>How do you know your change doesn't break anybody else's code? How can you make sure you're using this new endpoint correctly?</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Service oriented architecture</h3>

                    <img data-src="images/services.png" style="box-shadow: none;" />

                    <aside class="notes">
                        <ul>
                            <li>How can we gain confidence in our changes? Typically the solution has been to write end-to-end tests, where you run these services in a test environment and make real calls to them</li>
                            <li>End-to-end tests are costly to run, eventually it gets infeasible to spin up all of your dependencies, which by the way might have dependencies of their own</li>
                            <li>People try to get by with unit tests</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Anatomy of a service call</h3>

                    <img data-src="images/service-call.png" style="box-shadow: none;" />

                    <aside class="notes">
                        <ul>
                            <li>The service defines it's API in a specification document; at Yelp we use OpenAPI for that</li>
                            <li>Each service has a client library that provides a pythonic interface for doing the network requests, based on the information in the spec</li>
                            <li>Is there a way to take advantage of this specification and provide "compile time" checks?</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>The OpenAPI spec</h3>

                    <pre><code class="yaml" data-trim>
/business/{business_id}/v1:
  get:
    operationId: business_info
    parameters:
    - $ref: '#/parameters/AcceptLanguage'
    - description: Business identifier
      in: path
      name: business_id
      required: true
      type: int
    responses:
      '200':
        schema:
          $ref: '#/definitions/Business'
...          
                </code></pre>

                    <p class="fragment" data-code-focus="1-2"></p>
                    <p class="fragment" data-code-focus="12-14"></p>

                    <aside class="notes">
                        <ul>
                            <li>This is how the definition of an endpoint looks like, in this case to retrieve information for a business</li>
                            <li>I've shortened and simplified the example slightly just so it fits on the screen</li>
                            <li>The response definition references a business object, let's take a look at that</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>An OpenAPI model</h3>

                    <pre><code class="yaml" data-trim>
Business:
  properties:
    address1:
      type: string
    address2:
      type: string
    alias:
      type: string
    has_business_upgrades:
      type: boolean
    review_rating:
      type: string
                </code></pre>

                    <aside class="notes">
                        <ul>
                            <li>Again, I shortened it down to the essentials, so I removed documentation and other unrelated markup</li>
                            <li>We've seen a business object definition like this already, right? This looks quite similar to how we'd define a NamedTuple or a TypedDict</li>
                            <li>note that review_rating is a str for historical reasons; this is very easy to miss</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Making a service call</h3>

                    <pre><code class="python" data-trim>
from business_clientlib.client import create_client

client = create_client(...)

business = client.business.business_info(
    business_id=business_id,
).result(timeout=TIMEOUT)

return business.review_rating
                </code></pre>

                    <p class="fragment" data-code-focus="3"></p>
                    <p class="fragment" data-code-focus="5"></p>

                    <aside class="notes">
                        <ul>
                            <li>The client object will have attributes that correspond to the data in the spec</li>
                            <li>The first level is based on the first part of the endpoint URL, the second level is the operation ID.</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Testing our network code</h3>

                    <pre><code class="python" data-trim>
def get_business_review_rating(business_id: int) -> float:
    business = client.business.business_info(
        business_id=business_id,
    ).result(timeout=TIMEOUT)

    return business.review_rating
                    </code></pre>

                    <pre class="fragment"><code class="python" data-trim>
def test_get_business_review_rating():
    mock_business = mock.Mock(review_rating=4.5)
    with mock.patch('my_package.client') as client:
        client.business.business_info.return_value.\
            result.return_value = mock_business

        review_rating = get_business_review_rating(5)

    assert review_rating == mock_business.review_rating
                    </code></pre>

                    <p class="fragment" data-code-focus="7"></p>
                    <p class="fragment" data-code-focus="9-10"></p>

                    <aside class="notes">
                        <ul>
                            <li>The test doesn't catch the error that we're not properly converting the rating to float (which is what we do want the function to return), since we're not correclty mocking the data we get from the other service</li>
                            <li>Catching these types of errors requires integration tests that spin up a version of the service you're calling</li>
                            <li>Can type annotations help us detect these errors?</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Generating typed objects and functions</h3>

                    <img src="images/stubs-from-spec.png" style="box-shadow: none;" />

                    <aside class="notes">
                        <ul>
                            <li>The spec already contains all of the information we need</li>
                            <li>The thing is, if you're manually writing those Python class annotations, they're bound to get out of sync with the spec</li>
                            <li>What if we parse the spec and generate annotations for each model definition in the spec</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Generating model annotations</h3>

                    <pre><code class="python" data-trim>
class Business():
    id: int
    address1: str
    address2: Optional[str]
    review_rating: str
                    </code></pre>

                    <aside class="notes">
                        <ul>
                            <li>This corresponds to the OpenAPI model definition</li>
                            <li>Developers still need to manually annotate the code with them</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Testing with type safe data model objecta</h3>

                    <pre><code class="python" data-trim>
def get_business_review_rating(business_id: int) -> float:
    business = client.business.business_info(
        business_id=business_id,
    ).result(timeout=TIMEOUT)

    return business.review_rating
                    </code></pre>

                    <pre class="fragment"><code class="python" data-trim>
def test_get_business_review_rating():
    mock_business = models.Business(review_rating=4.5)
    with mock.patch('get_business_future') as mock_future:
        mock_future.return_value.\
            result.return_value = mock_business

        review_rating = get_business_review_rating(5)

    assert review_rating == mock_business.review_rating
                    </code></pre>

                    <p class="fragment" data-code-focus="7"></p>

                    <pre class="fragment"><code class="text" data-trim>
error: Argument 1 to "Business" has incompatible
 type "float"; expected "str"
                    </code></pre>

                    <aside class="notes">
                        <ul>
                            <li>Our typed stubs make sure we provide properly typed mock data</li>
                            <li>Another way would be to write wrapper functions around each client call that uses these models as annotations for return values</li>
                            <li>But that gets tedious very fast, can we do it automatically?</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Annotating the client class</h3>

                    <pre><code class="python" data-trim>
business = client.business.business_info(
    business_id=business_id,
).result(timeout=TIMEOUT)
                    </code></pre>

                    <pre class="fragment"><code class="python" data-trim>
T = TypeVar('T')

class BusinessServiceClient:
    business: business_resource

class business_resource:
    def business_info(
        self,
        business_id: int,
    ) -> HttpFuture[Business]: ...

class HttpFuture(Generic[T]):
    def result(self, timeout: Optional[float]=None) -> T:
        ...

                    </code></pre>

                    <p class="fragment" data-code-focus="5"></p>
                    <p class="fragment" data-code-focus="6"></p>
                    <p class="fragment" data-code-focus="9"></p>
                    <p class="fragment" data-code-focus="12"></p>
                    <p class="fragment" data-code-focus="14"></p>
                    <p class="fragment" data-code-focus="15"></p>

                    <aside class="notes">
                        <ul>
                            <li>Fully type checked from start to end - including the function call chain</li>
                            <li>Makes sure you supply all required arguments, with the right type</li>
                            <li>Structured response objects, no possibility for mistyping an attribute name</li>
                            <li>Modern IDEs like PyCharm provide advanced intellisense and autocompletion</li>
                            <li>All of this is checked and verified before you wrote a single line of tests!</li>
                        </ul>
                    </aside>
                </section>

                
                <section data-background="images/slide-background.png">
                    <h3>Take aways</h3>

                    <ul>
                        <li>Annotate your code to <strong>improve documentation</strong> and <strong>catch bugs earlier</strong></li>
                        <li class="fragment">With fine-grained typed data structures you gain a lot of insights into the data flow of your application</li>
                        <li class="fragment">Potentially reduce the number of tests you have to write</li>
                        <li class="fragment">Make the tests you do write more correct and comprehensive, and therefore <strong>more valuable</strong></li>
                        <li class="fragment">You can use <strong>generated annotations</strong> to type check communication across network boundaries</li>
                    </ul>

                    <aside class="notes">
                        <ul>
                            <li>One thing I'll note is that ramping up on Python type annotations does take up time.</li>
                            <li>Figuring out generics, how to annotate duck typed code or why mypy doesn't seem to "get it" in corner cases takes up time</li>
                            <li>Same thing with just figuring out what the correct annotation is when all you get is a dict you don't really know much about</li>
                            <li>Make sure you communicate early and honestly with your team</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/check_out_yelp.png">
                    <br />
                    <aside class="notes">
                        <p>Check out our engineering blog</p>
                        <p>Also check us out on GitHub, you'll find pre-commit there as well as a bunch of other neat stuff like bravado for service communication</p>
                    </aside>
                </section>


                <section data-background="images/we_are_hiring.png">
                    <br />

                    <aside class="notes">
                        <ul>
                            <li>Engineering offices in Hamburg, Germany, London and San Francisco</li>
                            <li>We do lots of cool stuff with Python 3.6 such as type annotations, asynchronous programming and more</li>
                            <li>Come talk to us at the booth!</li>
                        </ul>
                    </aside>
                </section>

            </div>
        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>

        <script>
            // More info https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                history: true,
                center: true,
                controls: false,
                width: '90%',
                height: '100%',
                margin: 0.0,
                width: 1920,
                height: 1200,

                // More info https://github.com/hakimel/reveal.js#dependencies
                // { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
                dependencies: [
                    { src: 'plugin/markdown/marked.js' },
                    { src: 'plugin/markdown/markdown.js' },
                    { src: 'plugin/notes/notes.js', async: true },
                    { src: 'vendor/highlight.js/highlight.pack.js' },
                    { src: 'node_modules/reveal-code-focus/reveal-code-focus.js', callback: function() { RevealCodeFocus(); } }
                ]
            });
        </script>
    </body>
</html>
