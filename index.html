<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <title>reveal.js</title>

        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/beige.css">

        <!-- Theme used for syntax highlighting of code -->
        <link rel="stylesheet" href="lib/css/zenburn.css">

        <link rel="stylesheet" href="vendor/highlight.js/styles/ocean.css">

        
        <style>
            section {
                font-size: larger !important;
                padding: 0 !important;
            }
            pre code {
                max-height: 100% !important;
                font-size: larger !important;
            }
            code.text {
                background-color: #fed;
            }
            img {
                border: 0 !important;
            }
            .reveal .slides section .fragment.current-only {
                opacity: 1;
                visibility: visible;
                display: none;
            }
            .reveal .slides section .fragment.current-only.current-fragment {
                display: block;
            }
            .line {
                display: block;
            }
            .line.focus {
                background: #111;
                font-weight: bold;
            }
        </style>

        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>
    </head>
    <body>
        <div class="reveal">
            <div class="slides">
                

                <section data-background="images/title-slide-background.png">
                    <h2>Migrating existing codebases to using type annotations</h2>
                    <p><small>Stephan Jaensch<br />@s_jaensch</small></p>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Yelp's mission</h3>

                    <p>To connect people to great local businesses</p>

                    <img src="images/yelp_mission_icons.png" style="box-shadow: none;" />

                    <aside class="notes">
                        <ul>
                            <li>We have over 130 million reviews online to help you select just the right one</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>What I'll talk about</h3>

                    <ul>
                        <li>What are type annotations, and why you should use them</li>
                        <li class="fragment">How do you incrementally migrate an existing codebase to them</li>
                        <li class="fragment">What are some issues you might encounter</li>
                        <li class="fragment">How can type annotations help across services</li>
                    </ul>

                    <aside class="notes">
                        <ul>
                            <li>I promise the what and why will be short</li>
                            <li>I'm by no means an expert on type annotations, I'm just talking about what I learned as a user</li>
                            <li>If you have tips or improvements to share, please come talk to me afterwards or contact me by email / twitter</li>
                            <li>I'll be showing a lot of code to illustrate my examples, so if you don't like slides with code you might want to leave now</li>
                        </ul>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Python type annotations</h3>

                    <pre><code class="python" data-trim>
def hello(who: str) -> str:
    return 'Hello, {}'.format(who)

hello(5)
                    </code></pre>

                    <pre class="fragment"><code class="text" data-trim>
error: Argument 1 to "hello" has incompatible type "int";
 expected "str"
                    </code></pre>

                    <aside class="notes">
                        <ul>
                            <li>Yes it's an obvious mistake, plus the code would still work</li>
                            <li>Much less clear when data gets passed around between modules, call stack gets deep</li>
                            <li>Also if it was fine to call the function with an int you should say so</li>
                            <li>Big difference in attitude to "duck typing"</li>
                            <li>This is really a continuation of explicit is better than implicit</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Migrate a codebase to using type annotations</h3>

                    <ul>
                        <li>Goal: All code is type annotated</li>
                        <li>Incrementally annotate code</li>
                        <li>Make sure checks are run for annotated code</li>
                    </ul>
                    
                    <aside class="notes">
                        <ul>
                            <li>We want to distribute the task of annotating the codebase</li>
                            <li>We want to progressively improve the amount of annotated code, while protecting against regressions</li>
                            <li>We're going to do that on a per-file basis: As people touch a file, we expect them to annotate it</li>
                            <li>Also, we do want to have type checking for the code that we already annotated. As we'll see, that is possible, although there are limitations.</li>
                        </ul>
                    </aside>
                </section>



                <section data-background="images/slide-background.png">
                    <h3>The mypy type checker</h3>

                    <img src="images/mypy-release.png" />

                    <aside class="notes">
                        <ul>
                            <li>mypy is the static type checker for Python</li>
                            <li>beta quality: rapid progress, but still has a few bugs and things it doesn't check correctly</li>
                            <li>expect having to do source code modifcations as you upgrade to a newer version</li>
                            <li>I'll also be using Python 3.6 syntax for annotations</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Enforce annotations</h3>

                    <pre><code class="ini" data-trim>
[mypy]
check_untyped_defs = True
disallow_untyped_calls = False
disallow_untyped_defs = True
follow_imports = silent
ignore_missing_imports = True
python_version = 3.6
strict_optional = True
warn_redundant_casts = True
                    </code></pre>

                    <p class="fragment" data-code-focus="2-4"></p>
                    <p class="fragment" data-code-focus="5-6"></p>
                    <p class="fragment" data-code-focus="8"></p>
                    
                    <aside class="notes">
                        <ul>
                            <li>non-annotated code is an error</li>
                            <li>Don't complain about issues in code we're not explicitly checking</li>
                            <li>Make sure you treat None correctly everywhere, significant source of bugs</li>
                            <li>mypy has a --strict option that's even stricter than this configuration - need to strike a balance between cost and benefit, especially since e.g. decorators are not always easy to annotate</li>
                            <li>So now we know how mypy needs to be configured, but how do we check newly committed code?</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Checking source code on commit</h3>

                    <img src="images/pre-commit.png" />
                    
                    <aside class="notes">
                        <ul>
                            <li>Yelp has you covered, we open sourced pre-commit</li>
                            <li>"Hooks" check your code on commit</li>
                            <li>Many hooks for a lot of different languages available</li>
                            <li>Very good Python support, as we are heavy Python users</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Configuring pre-commit</h3>

                    <pre><code class="yaml" data-trim>
-   repo: local
    hooks:
    -   id: mypy
        name: mypy
        entry: mypy
        language: python
        language_version: 'python3.6'
        additional_dependencies: ['mypy']
        args: ['--config-file', 'mypy-pre-commit.ini']
        files: ^package_name/.+\.py$
                    </code></pre>

                    <p class="fragment" data-code-focus="9-10"></p>

                    <pre class="fragment"><code class="bash" data-trim>pre-commit install -f --install-hooks</code></pre>
                    
                    <aside class="notes">
                        <ul>
                            <li>Create a .pre-commit-config.yaml file in your project directory</li>
                            <li>Save the mypy configuration we just discussed, and tell mypy to use it</li>
                            <li>Make sure everybody has the hooks installed: Run the install command as part of your test suite, or during a "setup" step</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Checking source code on commit</h3>

                    <img src="images/pre-commit-mypy.png" />

                    <aside class="notes">
                        <ul>
                            <li>I modified media.py, our pre-commit hook informs me that I forgot to fully annotate two functions; I also passed an argument of the wrong type to GetPhotosFuture</li>
                            <li>As you can see, there's many more hooks you can run to improve code consistency and quality</li>
                            <li>Note that this is not a foolproof solution; developers can skip individual hooks or pre-commit altogether</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Running mypy as part of your test suite</h3>

                    <pre><code class="ini" data-trim>
[mypy]
ignore_missing_imports = True
python_version = 3.6
strict_optional = True
warn_redundant_casts = True
                    </code></pre>
                    
                    <aside class="notes">
                        <ul>
                            <li>Less strict, totally OK to have non-annotated code</li>
                            <li>Once you call a function that is not annotated we have no type checking at all for its return value!</li>
                            <li>In the beginning you won't notice much of an improvement in terms of bug prevention - keep at it!</li>
                        </ul>
                    </aside>
                </section>



                <section data-background="images/slide-background.png">
                    <h3>Type your data</h3>

                    <pre><code class="python" data-trim>
from typing import Iterable, NamedTuple, Optional

class Business(NamedTuple):
    id: int
    name: str
    photos: Iterable[Photo]
    address1: Optional[str]
    address2: Optional[str]
    address3: Optional[str]
    city: str
    latitude: float
    longitude: float
    ...
                    </code></pre>

                    <p class="fragment" data-code-focus="6"></p>

                    <aside class="notes">
                        <ul>
                            <li>A lot of bugs happen because opaque dictionaries are passed around</li>
                            <li>Even worse, sometimes these dictionaries are mutated along the way</li>
                            <li>NamedTuples are a great way to defining your data contract, plus they're immutable</li>
                            <li>As you can see here, you can nest definitions</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>typed dictionaries</h3>

                    <pre><code class="python" data-trim>
from typing import Optional
from mypy_extensions import TypedDict

class BusinessDict(TypedDict):
    id: int
    name: str
    address1: Optional[str]
    address2: Optional[str]
                    </code></pre>

                    <pre class="fragment"><code class="python" data-trim>
business = BusinessDict(
    id=42, name='Yelp', address1=None, address2=None,
)
value = business.get('adress2', '')
                    </code></pre>

                    <pre class="fragment"><code class="text" data-trim>
error: TypedDict "BusinessDict" has no key 'adress2'
                    </code></pre>

                    <aside class="notes">
                        <ul>
                            <li>Unlike maps in other languages, you can have different types based on the key name</li>
                            <li>So even if you can't or don't want to do the work to convert your dicts to namedtuples, you can annotate those dicts and give them such a type</li>
                            <li>We can, but don't have to use those classes in our code, it's enough to use them as annotations</li>
                            <li>And mypy will protect us from a class of pretty insidious bugs: no exception is raised, the code seems to function properly but returns the wrong data</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>How to type the helper function?</h3>

                    <pre><code class="python" data-trim>
def namedtuple_from_dict(
    nt_class,
    dict_values,
):
    """Create a namedtuple from a dict, using the namedtuple
    attribute names to look up values in the dict."""
    return nt_class._make(
        dict_values.get(k) for k in nt_class._fields
    )
                    </code></pre>

                    <aside class="notes">
                        <ul>
                            <li>Hopefully you're convinced that you want to use type safe data structures, so let's use namedtuples everywhere!</li>
                            <li>To make that as easy as possible for developers, we provide a helper function for converting all of those untyped dictionaries into NamedTuples</li>
                            <li>It instantiates the NamedTuple class by looking up the property names of the NamedTuple in the dictionary - we use the NamedTuple definition as the source of truth for the data we want to keep</li>
                            <li>Should be easy to annotate, right?</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>How to type the helper function?</h3>

                    <pre><code class="python" data-trim>
def namedtuple_from_dict(
    nt_class: Type[NamedTuple],
    dict_values: Dict[str, Any],
) -> NamedTuple:
    """Create a namedtuple from a dict, using the namedtuple
    attribute names to look up values in the dict."""
    return nt_class._make(
        dict_values.get(k) for k in nt_class._fields
    )
                    </code></pre>

                    <p class="fragment" data-code-focus="2-4"></p>

                    <pre class="fragment"><code class="text" data-trim>
error: Incompatible return value type
 (got "NamedTuple", expected "Business")
error: Argument 1 to "namedtuple_from_dict" has incompatible
 type "Type[Business]"; expected "Type[NamedTuple]"
                    </code></pre>

                    <aside class="notes">
                        <ul>
                            <li>nt_class is a NamedTuple class, not an instance, that's why we need to use Type</li>
                            <li>This way to annotate dicts doesn't really tell us much about its contents</li>
                            <li>And we return an instance of that NamedTuple class</li>
                            <li>Unfortunately this doesn't work, as we do care about what NamedTuple instance we're returning</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Using Generics</h3>

                    <pre><code class="python" data-trim>
Struct = TypeVar('Struct', bound=NamedTuple)

def namedtuple_from_dict(
    nt_class: Type[Struct],
    dict_values: Dict,
) -> Struct:
    """Create a namedtuple from a dict, using the namedtuple
    attribute names to look up values in the dict."""
    return nt_class._make(
        dict_values.get(k) for k in nt_class._fields
    )
                    </code></pre>

                    <p class="fragment" data-code-focus="1"></p>
                    <p class="fragment" data-code-focus="4,6"></p>

                    <pre class="fragment"><code class="text" data-trim>
error: Value of type variable "Struct" of "namedtuple_from_dict"
 cannot be "Business"
                    </code></pre>

                    <aside class="notes">
                        <ul>
                            <li>So we read up on how generics work and implement that solution</li>
                            <li>We introduce a new TypeVar, and declare that a Struct must inherit from NamedTuple</li>
                            <li>Unfortunately, this doesn't work either: NamedTuple is not a class, but a class constructor</li>
                            <li>This is also the reason for the second error on the last slide, why Business was not acceptable instead of NamedTuple</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>The solution</h3>

                    <pre><code class="python" data-trim>
Struct = TypeVar('Struct')

def namedtuple_from_dict(
    nt_class: Type[Struct],
    dict_values: Dict,
) -> Struct:
    """Create a namedtuple from a dict, using the namedtuple
    attribute names to look up values in the dict."""
    return nt_class._make(    # type: ignore
        dict_values.get(k) for k in nt_class._fields  # type: ignore
    )
                    </code></pre>

                    <p class="fragment" data-code-focus="1"></p>
                    <p class="fragment" data-code-focus="9-10"></p>
                    <p class="fragment"><a href="https://github.com/python/mypy/issues/3915">https://github.com/python/mypy/issues/3915</a></p>

                    <aside class="notes">
                        <ul>
                            <li>We need to remove the bounding; but now all we know is that we receive a class of some type and return an instance</li>
                            <li>We lost knowledge about the fact that each of these classes will have a _field attribute and a _make method</li>
                            <li>So we need to tell mypy to ignore these errors</li>
                            <li>We still maintain the most important type information: the type of the instance we return</li>
                            <li>But mypy cannot tell us when we pass an argument in that is not a NamedTuple</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>NamedTuple and count / index</h3>

                    <pre><code class="python" data-trim>
class Pagination(NamedTuple):
    count: int
    index: int
                    </code></pre>

                    <pre class="fragment"><code class="text" data-trim>
error: Incompatible types in assignment (expression has type "int",
 base class "tuple" defined the type as
 "Callable[[Tuple[int, ...], Any], int]")

error: Incompatible types in assignment (expression has type "int",
 base class "tuple" defined the type as
 "Callable[[Tuple[int, ...], Any, int, int], int]")
                    </code></pre>

                    <aside class="notes">
                        <ul>
                            <li>tuples have index and count methods, our properties are shadowing them</li>
                            <li>The NamedTuple behaves as expected (we just can't call count or index anymore)</li>
                            <li>But mypy will complain as it doesn't allow us to redefine the type of those two properties</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Redefining the type of properties</h3>

                    <pre><code class="python" data-trim>
class RegistryMetaclass(type):
    """Error mapping registry class."""
    registry: Dict[str, Type['BaseErrorMapping']] = {}
    key_name: str = 'error_id'

class ValidationRegistryMetaclass(RegistryMetaclass):
    registry: Dict[str, Type['BaseValidationError']] = {}
    key_name = 'exc_cls'
                    </code></pre>

                    <pre class="fragment"><code class="text" data-trim>
error: Incompatible types in assignment (expression has type
 "Dict[str, Type[BaseValidationError]]", base class "RegistryMetaclass"
 defined the type as "Dict[str, Type[BaseErrorMapping]]")
                    </code></pre>

                    <p class="fragment"><a href="https://www.python.org/dev/peps/pep-0544/">https://www.python.org/dev/peps/pep-0544/</a></p>

                    <aside class="notes">
                        <ul>
                            <li>you can try defining the type in the base class as a union, but that can have other unintended consequences</li>
                            <li>The Protocols PEP will solve this and allow us to define behavior, i.e. support static duck typing</li>
                            <li>structural subtyping should also enable us to properly type the namedtuple_from_dict function</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>How to annotate descriptors</h3>

                    <pre><code class="python" data-trim>
T = TypeVar('T')
V = TypeVar('V')

class SetOnceProperty(Generic[T, V]):

    def __get__(self, instance: Optional[T], owner: Type[T])
     -> Union[V, 'SetOnceProperty']:
        if instance is None:
            return self
        return self._property_map[instance]

    def __set__(self, instance: T, value: V) -> None:
        if instance in self._property_map:
            raise AttributeError('this attribute can only be set once.')
        self._property_map[instance] = value


class BizAppContext():
    biz_user_id = SetOnceProperty['BizAppContext', int]()
    ...
                    </code></pre>

                    <p class="fragment" data-code-focus="4"></p>
                    <p class="fragment" data-code-focus="6-7"></p>
                    <p class="fragment" data-code-focus="13-14"></p>
                    <p class="fragment" data-code-focus="19"></p>

                    <img class="fragment" data-src="images/document-descriptors.png" />

                    <aside class="notes">
                        <ul>
                            <li>Generic class, T is the type of the object using the descriptor, V the type of the value the property will store</li>
                            <li>Typing the __get__ method is slightly tricky, as instance can be None, that's why we use Optional[T]</li>
                            <li>And in that case the descriptor returns itself, so we have to annotate the return value as a Union</li>
                            <li>The __set__ method is where we implement the functionality</li>
                            <li>when we define biz_user_id we specify the two types, so now mypy knows biz_user_id is an int and will do proper type checking</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Recursive types</h3>

                    <pre><code class="python" data-trim>
class Category(NamedTuple):
    id: int
    name: str
    children: List['Category']
                    </code></pre>

                    <pre class="fragment"><code class="text" data-trim>
error: Recursive types not fully supported yet,
 nested types replaced with "Any"
                    </code></pre>

                    <img class="fragment" data-src="images/recursive-types.png" />

                    <aside class="notes">
                        <ul>
                            <li>Another mypy limitation that you'll probably hit when working with a larger codebase</li>
                            <li>Tree-like data structures will probably be mostly untyped</li>
                            <li>You can add typing information with the cast function, but you'll have to remember to do this everywhere</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h2>Type annotations with distributed code</h2>

                    <aside class="notes">
                        <ul>
                            <li>If you have a large legacy codebase, chances are you've started to invest in a service oriented architecture (we at Yelp certainly have)</li>
                            <li>I've spoken in the past about how we do distributed services at Yelp, and the challenges it poses in regards to reliability and testability with these codebases that get developed and deployed independently.</li>
                            <li>How do you know your change doesn't break anybody else's code? How can you make sure you're using this new endpoint correctly?</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Service oriented architecture</h3>

                    <img data-src="images/services.png" style="box-shadow: none;" />

                    <aside class="notes">
                        <ul>
                            <li>How can we gain confidence in our changes? Typically the solution has been to write end-to-end tests, where you create these services in a test environment and make real calls to them</li>
                            <li>End-to-end tests are costly to run, eventually it gets infeasible to spin up all of your dependencies, which by the way might have dependencies of their own</li>
                            <li>One solution that can help is using fake services. My colleague Lauris is talking about that right now in the other room, but spoiler alert, it still involves launching other processes, typically in a Docker container</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Anatomy of a service call</h3>

                    <img data-src="images/service-call.png" style="box-shadow: none;" />

                    <aside class="notes">
                        <ul>
                            <li>The service defines it's API in a spec document</li>
                            <li>The client uses a library that knows about the spec, parses and utilizes it for making the endpoint calls</li>
                            <li>Is there a way to take advantage of this spec and provide "compile time" checks?</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>The OpenAPI spec</h3>

                    <pre><code class="yaml" data-trim>
/business/{business_id}/v1:
  get:
    operationId: business_info
    parameters:
    - $ref: '#/parameters/AcceptLanguage'
    - description: Business identifier
      in: path
      name: business_id
      required: true
      type: int
    responses:
      '200':
        schema:
          $ref: '#/definitions/Business'
...          
                </code></pre>

                    <p class="fragment" data-code-focus="1-2"></p>
                    <p class="fragment" data-code-focus="12-14"></p>

                    <aside class="notes">
                        <ul>
                            <li>This is how the definition of an endpoint looks like, in this case to retrieve information for a business</li>
                            <li>I've shortened and simplified the example slightly just so it fits on the screen</li>
                            <li>The response definition references a business object, let's take a look at that</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>An OpenAPI model</h3>

                    <pre><code class="yaml" data-trim>
Business:
  properties:
    address1:
      type: string
    address2:
      type: string
    alias:
      type: string
    has_business_upgrades:
      type: boolean
    review_rating:
      type: string
                </code></pre>

                    <aside class="notes">
                        <ul>
                            <li>Again, I shortened it down to the essentials, so I removed documentation and other unrelated markup</li>
                            <li>We've seen a business object definition like this already, right? This looks quite similar to how we'd define a NamedTuple or a TypedDict</li>
                            <li>The thing is, if you're manually writing those Python class definitions, they're bound to get out of sync with the spec</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Generating typed objects and functions</h3>

                    <img src="images/stubs-from-spec.png" style="box-shadow: none;" />

                    <aside class="notes">
                        <ul>
                            <li>The spec already contains all of the information we need</li>
                            <li>What if we parse the spec and generate NamedTuple objects for each model definition in the spec</li>

                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Putting it all together</h3>

                    <pre><code class="python" data-trim>
class BusinessFuture(HTTPFuture):
    pass

class Business(NamedTuple):
    id: int
    address1: str
    address2: Optional[str]
    review_rating: str
                    </code></pre>

                    <pre class="fragment"><code class="python" data-trim>
def get_business_future(
    business_id: int
) -> BusinessFuture:
    return client.business.business_info(
        business_id=business_id,
    )

def get_business_from_future(
    business_future: BusinessFuture,
) -> Business:
    return business_future.result(timeout=TIMEOUT)
                    </code></pre>

                    <aside class="notes">
                        <ul>
                            <li>Fully type checked from start to end - including the function call chain</li>
                            <li>Makes sure you supply all required arguments, with the right type</li>
                            <li>Structured response objects, no possibility for mistyping an attribute name</li>
                            <li>Modern IDEs like PyCharm provide advanced intellisense and autocompletion</li>
                            <li>All of this is checked and verified before you wrote a single line of tests!</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Mocking out the network call</h3>

                    <pre><code class="python" data-trim>
def get_business_review_rating(business_id):
    business = client.business.business_info(
        business_id=business_id,
    ).result(timeout=TIMEOUT)

    return business.review_rating
                    </code></pre>

                    <pre class="fragment"><code class="python" data-trim>
def test_get_business_review_rating():
    mock_business = mock.Mock(review_rating=4.5)
    with mock.patch('my_package.client') as client:
        client.business.business_info.return_value.\
            result.return_value = mock_business

        review_rating = get_business_review_rating(5)

    assert review_rating == mock_business.review_rating
                    </code></pre>

                    <p class="fragment" data-code-focus="7"></p>

                    <aside class="notes">
                        <ul>
                            <li>This doesn't catch the error that we're providing the wrong mock data, and consequently are not properly converting the rating to float (which is what we do want the function to return)</li>
                            <li>Catching these types of errors requires integration tests that spin up a version of the service you're calling</li>
                            <li>My colleague Lauris Jullien is giving a talk right now about how to make that easier, but spoiler alert, it still requires you to spin up another process, typically within a Docker container</li>
                            <li>Can our work we did help us detect these errors easier?</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/slide-background.png">
                    <h3>Testing with type safe models</h3>

                    <pre><code class="python" data-trim>
def get_business_review_rating(business_id):
    business = get_business_from_future(
        get_business_future(5),
    )

    return business.review_rating
                    </code></pre>

                    <pre class="fragment"><code class="python" data-trim>
def test_get_business_review_rating():
    mock_business = models.Business(review_rating=4.5)
    with mock.patch('get_business_future') as mock_future:
        mock_future.return_value.\
            result.return_value = mock_business

        review_rating = get_business_review_rating(5)

    assert review_rating == mock_business.review_rating
                    </code></pre>

                    <p class="fragment" data-code-focus="7"></p>

                    <pre class="fragment"><code class="text" data-trim>
error: Argument 1 to "Business" has incompatible
 type "float"; expected "str"
                    </code></pre>

                    <aside class="notes">
                        <ul>
                            <li>In Yelp's case, when you instantiate a model, you get the actual model class - the NamedTuple code is just used for annotating it</li>
                            <li>But even if you use NamedTuple objects you'll be doing a better job of mocking the data than with mock objects</li>
                            <li>Our typed stubs make sure we provide properly typed mock data</li>
                            <li>If we annotate our get_business_review_rating function, it'll also tell us that we expect a float, not a string - even without a test!</li>
                            <li>And the pre-commit hook we talked about earlier makes sure that function will be annotated when you write it!</li>
                        </ul>
                    </aside>
                </section>


                
                <section data-background="images/slide-background.png">
                    <h3>Take aways</h3>

                    <ul>
                        <li>Annotate your code to <strong>improve documentation</strong> and <strong>catch bugs earlier</strong></li>
                        <li class="fragment">With fine-grained typed data structures you gain a lot of insights into the data flow of your application</li>
                        <li class="fragment">Potentially reduce the number of tests you have to write</li>
                        <li class="fragment">Make the tests you do write more correct and comprehensive, and therefore <strong>more valuable</strong></li>
                        <li class="fragment">You can use <strong>generated annotations</strong> to type check communication across network boundaries</li>
                    </ul>

                    <aside class="notes">
                        <ul>
                            <li>One thing I'll note is that ramping up on Python type annotations does take up time.</li>
                            <li>Figuring out generics, how to annotate duck typed code or why mypy doesn't seem to "get it" in corner cases takes up time</li>
                            <li>Same thing with just figuring out what the correct annotation is when all you get is a dict you don't really know much about</li>
                            <li>Make sure you communicate early and honestly with your team</li>
                        </ul>
                    </aside>
                </section>


                <section data-background="images/check_out_yelp.png">
                    <br />
                    <aside class="notes">
                        <p>Check out our engineering blog</p>
                        <p>Also check us out on GitHub, you'll find pre-commit there as well as a bunch of other neat stuff like bravado for service communication</p>
                    </aside>
                </section>


                <section data-background="images/we_are_hiring.png">
                    <br />

                    <aside class="notes">
                        <ul>
                            <li>Engineering offices in Hamburg, Germany, London and San Francisco</li>
                            <li>We do lots of cool stuff with Python 3.6 such as type annotations, asynchronous programming and more</li>
                            <li>Come talk to us at the booth!</li>
                        </ul>
                    </aside>
                </section>

            </div>
        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>

        <script>
            // More info https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                history: true,
                center: true,
                controls: false,
                width: '90%',
                height: '100%',
                margin: 0.0,

                // More info https://github.com/hakimel/reveal.js#dependencies
                // { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
                dependencies: [
                    { src: 'plugin/markdown/marked.js' },
                    { src: 'plugin/markdown/markdown.js' },
                    { src: 'plugin/notes/notes.js', async: true },
                    { src: 'vendor/highlight.js/highlight.pack.js' },
                    { src: 'node_modules/reveal-code-focus/reveal-code-focus.js', callback: function() { RevealCodeFocus(); } }
                ]
            });
        </script>
    </body>
</html>
